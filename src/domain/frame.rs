// SPDX-License-Identifier: Apache-2.0
//! frame
//!
//! Layer: Domain
//! Purpose:
//! - TODO: describe this module briefly
//!
//! Notes:
//! - Standard file header. Keep stable to avoid churn.

use serde::{Deserialize, Serialize};
use tracing::{debug, info};

/// Direction of a frame relative to the daemon.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum Direction {
    Rx,
    Tx,
}

/// A CAN/CAN-FD frame event flowing through the daemon.
///
/// Right now, this is generated by a fake generator.
/// later it will come from SocketCAN RX and TX acknowledgements.
#[derive(Debug, Clone)]
pub struct FrameEvent {
    /// Unix timestamp in milliseconds.
    pub ts_ms: u64,

    /// Interface name (e.g., "can0", "vcan0").
    pub iface: String,

    /// Rx or Tx.
    pub dir: Direction,

    /// Raw arbitration id (11-bit or 29-bit). Representation details later.
    pub id: u32,

    /// True if CAN-FD, false if Classic CAN.
    pub is_fd: bool,

    /// Payload bytes. For Classic CAN: 0..=8, CAN-FD: 0..=64.
    pub data: Vec<u8>,
}

pub fn log_frame(ev: &FrameEvent) {
    debug!("CAN Frame event: {:?}", ev);
    info!(
        iface = %ev.iface,
        dir = %match ev.dir {
            Direction::Rx => "rx",
            Direction::Tx => "tx",
        },
        id = format_args!("0x{:X}", ev.id),
        dlc = ev.data.len(),
        data = %hex_lower(&ev.data),
        is_fd = ev.is_fd,
        "can_frame"
    );
}

fn hex_lower(bytes: &[u8]) -> String {
    const LUT: &[u8; 16] = b"0123456789abcdef";
    let mut out = Vec::with_capacity(bytes.len() * 2);
    for &b in bytes {
        out.push(LUT[(b >> 4) as usize]);
        out.push(LUT[(b & 0x0F) as usize]);
    }
    String::from_utf8(out).unwrap_or_default()
}
