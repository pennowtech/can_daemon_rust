// SPDX-License-Identifier: Apache-2.0
//! transport_tcp
//!
//! Layer: Infrastructure
//! Purpose:
//! - TODO: describe this module briefly
//!
//! Notes:
//! - Standard file header. Keep stable to avoid churn.

use std::{
    collections::HashSet,
    net::SocketAddr,
    sync::{
        atomic::{AtomicU64, Ordering},
        Arc,
    },
    time::Duration,
};

use anyhow::{Context, Result};
use tokio::{
    io::{AsyncBufReadExt, AsyncWriteExt, BufReader},
    net::{TcpListener, TcpStream},
    sync::{mpsc, Mutex},
    time,
};
use tracing::{debug, info, warn};

use crate::{
    app::BridgeService,
    domain::{
        frame::{Direction, FrameEvent},
        protocol::{ClientRequest, ServerResponse},
    },
};

pub struct TcpJsonlServer {
    addr: SocketAddr,
    next_conn_id: AtomicU64,
}

impl TcpJsonlServer {
    pub fn new(addr: SocketAddr) -> Self {
        Self {
            addr,
            next_conn_id: AtomicU64::new(1),
        }
    }

    pub async fn run(&self, service: BridgeService) -> Result<()> {
        let listener = TcpListener::bind(self.addr)
            .await
            .with_context(|| format!("failed to bind TCP listener on {}", self.addr))?;

        info!(addr=%self.addr, "tcp server listening (jsonl)");

        loop {
            let (stream, peer) = listener.accept().await?;
            let conn_id = self.next_conn_id.fetch_add(1, Ordering::Relaxed);

            info!(%conn_id, %peer, "client connected");

            let svc = service.clone();
            tokio::spawn(async move {
                if let Err(e) = handle_connection(conn_id, peer, stream, svc).await {
                    warn!(%conn_id, %peer, error=%e, "client handler ended with error");
                } else {
                    info!(%conn_id, %peer, "client handler ended");
                }
            });
        }
    }
}

async fn handle_connection(
    conn_id: u64,
    peer: SocketAddr,
    stream: TcpStream,
    service: BridgeService,
) -> Result<()> {
    // Split into reader and writer halves.
    let (read_half, write_half) = stream.into_split();
    let mut reader = BufReader::new(read_half);

    // Per-connection subscription set.
    let subscribed_ifaces: Arc<Mutex<HashSet<String>>> = Arc::new(Mutex::new(HashSet::new()));

    // Channel for responses generated by reader/service to be written by writer.
    let (resp_tx, mut resp_rx) = mpsc::unbounded_channel::<ServerResponse>();

    // Broadcast receiver for frames.
    let mut frames_rx = service.subscribe_frames();

    // writer task -- writes responses and frame events to the socket
    // based on subscriptions.
    let writer_handle = {
        let subscribed_ifaces = subscribed_ifaces.clone();
        tokio::spawn(async move {
            let mut write_half = write_half;

            loop {
                tokio::select! {
                    // Responses (pong, ifaces, subscribed, error, etc.)
                    maybe_resp = resp_rx.recv() => {
                        let Some(resp) = maybe_resp else { break; };
                        if let Err(e) = write_jsonl(&mut write_half, &resp).await {
                            warn!(error=%e, "writer failed writing response");
                            break;
                        }
                    }

                    // Frame events from the internal bus
                    ev = frames_rx.recv() => {
                        match ev {
                            Ok(ev) => {
                                if should_send_frame(&subscribed_ifaces, &ev).await {
                                    let resp = frame_event_to_response(ev);
                                    if let Err(e) = write_jsonl(&mut write_half, &resp).await {
                                        warn!(error=%e, "writer failed writing frame");
                                        break;
                                    }
                                }
                            }
                            Err(tokio::sync::broadcast::error::RecvError::Lagged(n)) => {
                                // Receiver fell behind; messages were dropped.
                                // This is expected under heavy load; we log and continue.
                                warn!(dropped=%n, "frame receiver lagged; dropped messages");
                            }
                            Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                                break;
                            }
                        }
                    }
                }
            }
        })
    };

    // -----------------------------
    // Hello handshake
    // -----------------------------
    let hello = ServerResponse::Hello {
        version: "0.5".to_string(),
        features: vec!["tcp".into(), "jsonl".into(), "stream".into()],
        server_name: "can-bridge-daemon".to_string(),
    };

    debug!(%conn_id, %peer, "sending hello");
    resp_tx
        .send(hello)
        .map_err(|_| anyhow::anyhow!("writer task ended before hello could be sent"))?;

    // Require hello_ack within 3 seconds
    let mut first_line = String::new();
    let n = time::timeout(Duration::from_secs(3), reader.read_line(&mut first_line))
        .await
        .context("hello_ack timeout")??;

    if n == 0 {
        anyhow::bail!("client disconnected before hello_ack");
    }

    let raw = first_line.trim_end_matches(&['\r', '\n'][..]).to_string();
    debug!(%conn_id, %peer, raw=%raw, "rx handshake line");

    let req: ClientRequest = serde_json::from_str(&raw).context("invalid hello_ack json")?;

    match req {
        ClientRequest::HelloAck { client, protocol } => {
            info!(%conn_id, %peer, %client, %protocol, "hello_ack received");
        }
        other => anyhow::bail!("expected hello_ack, got: {:?}", other),
    }

    // -----------------------------
    // Normal request loop
    // -----------------------------
    let mut line = String::new();

    loop {
        line.clear();
        let n = reader.read_line(&mut line).await?;
        if n == 0 {
            debug!(%conn_id, %peer, "client EOF");
            break;
        }

        let raw = line.trim_end_matches(&['\r', '\n'][..]).to_string();
        debug!(%conn_id, %peer, raw=%raw, "rx line");

        let req: ClientRequest = match serde_json::from_str(&raw) {
            Ok(v) => v,
            Err(e) => {
                warn!(%conn_id, %peer, error=%e, raw=%raw, "bad json request");
                let _ = resp_tx.send(ServerResponse::Error {
                    message: format!("invalid json request: {e}"),
                });
                continue;
            }
        };

        debug!(%conn_id, %peer, req=?req, "parsed request");

        // Subscribe/unsubscribe are per-connection state; handle here.
        match req {
            ClientRequest::Subscribe { ifaces } => {
                {
                    let mut set = subscribed_ifaces.lock().await;
                    set.clear();
                    for i in &ifaces {
                        set.insert(i.clone());
                    }
                }
                let _ = resp_tx.send(ServerResponse::Subscribed { ifaces });
                continue;
            }
            ClientRequest::Unsubscribe => {
                {
                    let mut set = subscribed_ifaces.lock().await;
                    set.clear();
                }
                let _ = resp_tx.send(ServerResponse::Unsubscribed);
                continue;
            }
            _ => {}
        }

        // Everything else goes through the application service
        let resp = service.handle(req).await;
        let _ = resp_tx.send(resp);
    }

    // Close writer by dropping resp_tx, then wait briefly.
    drop(resp_tx);
    let _ = writer_handle.await;

    Ok(())
}

async fn should_send_frame(subscribed: &Arc<Mutex<HashSet<String>>>, ev: &FrameEvent) -> bool {
    let set = subscribed.lock().await;
    set.contains(&ev.iface)
}

fn frame_event_to_response(ev: FrameEvent) -> ServerResponse {
    ServerResponse::Frame {
        ts_ms: ev.ts_ms,
        iface: ev.iface,
        dir: match ev.dir {
            Direction::Rx => "rx".to_string(),
            Direction::Tx => "tx".to_string(),
        },
        id: ev.id,
        is_fd: ev.is_fd,
        data_hex: hex_lower(&ev.data),
    }
}

/// Lowercase hex string with no separators.
fn hex_lower(bytes: &[u8]) -> String {
    // Avoid extra deps; keep it simple.
    const LUT: &[u8; 16] = b"0123456789abcdef";
    let mut out = Vec::with_capacity(bytes.len() * 2);
    for &b in bytes {
        out.push(LUT[(b >> 4) as usize]);
        out.push(LUT[(b & 0x0F) as usize]);
    }
    String::from_utf8(out).unwrap_or_default()
}

async fn write_jsonl<W: AsyncWriteExt + Unpin>(w: &mut W, msg: &ServerResponse) -> Result<()> {
    let mut s = serde_json::to_string(msg)?;
    s.push('\n');
    w.write_all(s.as_bytes()).await?;
    w.flush().await?;
    Ok(())
}
